/**
 * @fileoverview Controller for user management operations.
 *  ไฟล์นี้จัดการตรรกะสำหรับเส้นทาง (routes) ที่เกี่ยวข้องกับการจัดการผู้ใช้
 */
import { FastifyRequest, FastifyReply } from 'fastify';
import * as UserService from './user.service'; // Using import * as UserService
import {
  // Assuming these types are generated by Fastify based on schemas or defined explicitly
  // For now, we'll use the schemas directly in the route definitions for validation
  // and trust Fastify to provide the correct types to the handlers.
  // We can later define specific types for request.Body, request.Query, request.Params if needed.
} from './user.schema'; // Schemas are used for validation by Fastify
import { UserResponse, CreateUserRequest, UpdateUserRequest, GetUsersQuery } from '../../types/user.types'; // For internal typing if necessary
import { BaseResponseKey, DeveloperMessages } from '../../common/constants';
import { sendSuccess, sendError } from '../../handlers/response.handler';

// ฟังก์ชันช่วยในการลบ passwordHash ออกจากอ็อบเจกต์ผู้ใช้
// Updated to reflect new entity structure (name instead of firstName, lastName)
const sanitizeUser = (user: any): UserResponse | null => {
  if (user && typeof user === 'object') {
    const { passwordHash, ...sanitizedUser } = user;
    return sanitizedUser as UserResponse; // Cast to UserResponse
  }
  return null;
};

// Helper function to exclude password hash from an array of users
const sanitizeUsers = (users: any[]): UserResponse[] => {
  return users.map(user => sanitizeUser(user)).filter(user => user !== null) as UserResponse[];
};

/**
 * Handles retrieval of all users with pagination, filtering, and sorting.
 * @param request The Fastify request object, expecting query parameters from GetUsersQuerySchema.
 * @param reply The Fastify reply object.
 */
export const getAllUsersController = async (
  request: FastifyRequest<{ Querystring: GetUsersQuery }>, // Type from user.types.ts, validated by schema
  reply: FastifyReply
) => {
  try {
    // request.query will be typed based on GetUsersQuerySchema by Fastify
    const result = await UserService.getAllUsers(request.query); // Service needs to handle query
    // Assuming service returns { users: User[], total: number, page: number, limit: number }
    // For now, let's assume it returns users directly and we sanitize.
    // Later, the service should return a structure that includes pagination details.
    sendSuccess(reply, {
        data: sanitizeUsers(result.users),
        pagination: {
            total: result.total,
            page: result.page,
            limit: result.limit,
            totalPages: Math.ceil(result.total / result.limit)
        }
    });
  } catch (error: any) {
    request.log.error(error, 'Get all users error');
    sendError(reply, BaseResponseKey.INTERNAL_ERROR);
  }
};

/**
 * Handles creation of a new user.
 * @param request The Fastify request object, expecting body from CreateUserBodySchema.
 * @param reply The Fastify reply object.
 */
export const createUserController = async (
  request: FastifyRequest<{ Body: CreateUserRequest }>, // Type from user.types.ts, validated by schema
  reply: FastifyReply
) => {
  try {
    // request.body will be typed based on CreateUserBodySchema
    const createdUser = await UserService.createUser(request.body);
    sendSuccess(reply, sanitizeUser(createdUser), BaseResponseKey.CREATED);
  } catch (error: any) {
    request.log.error(error, 'Create user error');
    if (error.message === DeveloperMessages.VALIDATION_FAIL_CUSTOMER_CODE_EXISTS ||
        error.message === DeveloperMessages.VALIDATION_FAIL_EMAIL_EXISTS) {
      sendError(reply, BaseResponseKey.CONFLICT, error, error.message);
    } else if (error.message.startsWith('Validation error:')) { // More generic validation
        sendError(reply, BaseResponseKey.VALIDATION_FAIL, error, error.message);
    }
    else {
      sendError(reply, BaseResponseKey.INTERNAL_ERROR);
    }
  }
};

/**
 * Handles updating an existing user.
 * @param request The Fastify request object, expecting user ID in Params and update data in Body.
 * @param reply The Fastify reply object.
 */
export const updateUserController = async (
  request: FastifyRequest<{ Params: { id: string }; Body: UpdateUserRequest }>,
  reply: FastifyReply
) => {
  const { id } = request.params;
  try {
    // request.body will be typed based on UpdateUserBodySchema
    const updatedUser = await UserService.updateUser(id, request.body);
    if (!updatedUser) {
      return sendError(reply, BaseResponseKey.NOT_FOUND, new Error(DeveloperMessages.USER_NOT_FOUND));
    }
    sendSuccess(reply, sanitizeUser(updatedUser));
  } catch (error: any) {
    request.log.error(error, `Update user (${id}) error`);
    if (error.message === DeveloperMessages.USER_NOT_FOUND) {
        sendError(reply, BaseResponseKey.NOT_FOUND, error, error.message);
    } else if (error.message === DeveloperMessages.VALIDATION_FAIL_EMAIL_EXISTS || error.message === DeveloperMessages.VALIDATION_FAIL_CUSTOMER_CODE_EXISTS) {
        sendError(reply, BaseResponseKey.CONFLICT, error, error.message);
    } else {
      sendError(reply, BaseResponseKey.INTERNAL_ERROR);
    }
  }
};

/**
 * Handles marking a user as inactive (soft delete).
 * @param request The Fastify request object, expecting user ID in Params.
 * @param reply The Fastify reply object.
 */
export const deleteUserController = async (
  request: FastifyRequest<{ Params: { id: string } }>,
  reply: FastifyReply
) => {
  const { id } = request.params;
  try {
    const success = await UserService.deleteUser(id); // Service marks as inactive
    if (!success) {
      // This case might indicate the user wasn't found or couldn't be deleted
      return sendError(reply, BaseResponseKey.NOT_FOUND, new Error(DeveloperMessages.USER_NOT_FOUND_OR_ALREADY_INACTIVE));
    }
    sendSuccess(reply, { success: true, message: 'User marked as inactive successfully.' });
  } catch (error: any) {
    request.log.error(error, `Delete user (${id}) error`);
    if (error.message === DeveloperMessages.USER_NOT_FOUND) {
        sendError(reply, BaseResponseKey.NOT_FOUND, error, error.message);
    } else {
        sendError(reply, BaseResponseKey.INTERNAL_ERROR);
    }
  }
};

/**
 * Handles resetting a user's password (placeholder).
 * @param request The Fastify request object, expecting user ID in Params.
 * @param reply The Fastify reply object.
 */
export const resetPasswordController = async (
  request: FastifyRequest<{ Params: { id: string } }>,
  reply: FastifyReply
) => {
  const { id } = request.params;
  try {
    // Placeholder logic for now, service should ideally handle this
    await UserService.resetPassword(id); // Assume service exists and handles it
    sendSuccess(reply, { success: true, message: 'Password reset initiated successfully (placeholder).' });
  } catch (error: any) {
    request.log.error(error, `Reset password for user (${id}) error`);
     if (error.message === DeveloperMessages.USER_NOT_FOUND) {
        sendError(reply, BaseResponseKey.NOT_FOUND, error, error.message);
    } else {
        sendError(reply, BaseResponseKey.INTERNAL_ERROR);
    }
  }
};

// getUserByIdController is not explicitly in the requirements, but was in the original file.
// If it's needed, it should be updated similarly. For now, it's removed to match requirements.
/*
export const getUserByIdController = async (
  request: FastifyRequest<{ Params: { id: string } }>,
  reply: FastifyReply
) => {
  const { id } = request.params;
  try {
    const user = await UserService.findUserById(id); // Assumes findUserById service function
    if (!user) {
      return sendError(reply, BaseResponseKey.NOT_FOUND, new Error(DeveloperMessages.USER_NOT_FOUND));
    }
    sendSuccess(reply, sanitizeUser(user));
  } catch (error: any) {
    request.log.error(error, `Get user by ID (${id}) error`);
    sendError(reply, BaseResponseKey.INTERNAL_ERROR);
  }
};
*/
